<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GridLock: A Computational Thinking Challenge</title>
<style>
:root{
  --green:#009B4C; --gray:#f4f7f8; --wall:#2f323b; --path:#ffffff;
  --start:#4fc3f7; --exit:#ffca28; --robot:#673ab7; --text:#1b1f24; --enemy:#e11d48;
}
*{box-sizing:border-box}
body{
  font-family:'Poppins',sans-serif;margin:0;background:var(--gray);color:var(--text);
  display:flex;flex-direction:column;min-height:100vh;
}
header{
  text-align:center;padding:12px 16px;background:#fff;border-bottom:1px solid #e8edf2;
}
h1{margin:0;font-size:22px;color:var(--green);letter-spacing:.2px}

main{
  max-width:1200px;margin:14px auto;display:grid;grid-template-columns:1fr 340px;gap:18px;padding:0 12px;
}
@media (max-width:980px){main{grid-template-columns:1fr}}

.board{background:#e7edf2;border-radius:14px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
#lab{
  --n:10;
  display:grid;gap:5px;justify-content:center;margin:auto;
  grid-template-columns:repeat(var(--n),50px);grid-template-rows:repeat(var(--n),50px);
}
.cell{
  width:50px;height:50px;border-radius:10px;background:var(--path);
  box-shadow:inset 0 0 0 1px #0001;position:relative;
}
.cell.wall{background:var(--wall)}
.cell.start{background:var(--start)}
.cell.exit{background:var(--exit)}
.bot{position:absolute;inset:0;display:grid;place-items:center;}
.bot svg{width:42px;height:42px;filter:drop-shadow(0 4px 8px rgba(0,0,0,.25))}
.bot .head{fill:var(--robot);stroke:#fff;stroke-width:5px}
.enemy{position:absolute;inset:0;display:grid;place-items:center;}
.enemy::after{
  content:"";width:28px;height:28px;border-radius:6px;background:var(--enemy);
  box-shadow:0 6px 12px rgba(225,29,72,.35), inset 0 0 0 2px #fff8;
}

.legend{display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap}
.lg{display:inline-flex;align-items:center;gap:6px;font-size:12px;background:#fff;border:1px solid #e6eaef;border-radius:999px;padding:6px 10px}
.dot{width:14px;height:14px;border-radius:4px;display:inline-block}

.panel{
  background:#fff;border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,.08);
  padding:14px;display:grid;gap:10px;
}
.section{border:1px solid #e6eaef;border-radius:12px;padding:12px}
.section h2{margin:0 0 10px;font-size:14px;color:var(--green);text-transform:uppercase;letter-spacing:.3px}

/* Controls */
.controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
.btn{
  display:inline-flex;align-items:center;justify-content:center;
  background:var(--green);color:#fff;border:none;border-radius:10px;
  padding:12px;font-weight:800;cursor:pointer;transition:background .2s;
  width:100%;min-height:44px;
}
.btn:hover{background:#007c3d}
.btn.turn{background:#2f323b}
.btn.turn:hover{background:#1f1f22}
.btn.reset{background:#c53030}
.btn.reset:hover{background:#a52020}
.btn:active{transform:translateY(1px)}

.status{display:flex;gap:8px;flex-wrap:wrap}
.badge{
  background:#f6faf8;border:1px solid #cfeadf;color:#073b26;border-radius:999px;
  padding:6px 10px;font-weight:800;font-size:13px
}

/* Pillars */
.pillars{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.pillar{
  background:#f7f9fc;border:1px solid #e3e9f2;border-radius:10px;
  padding:8px;text-align:center;font-weight:700;font-size:13px;transition:all .25s ease;
}
.pillar.on{background:#e9fff3;border-color:#b9efcf;transform:scale(1.04)}
.pillar-msg{
  margin-top:8px;background:#fbfeff;border:1px dashed #cfeadf;border-radius:10px;padding:8px;font-size:13px;min-height:42px;
}
footer{
  text-align:center;margin-top:auto;padding:12px;font-weight:700;color:var(--green);
}
</style>
</head>
<body>
<header><h1>GridLock: A Computational Thinking Challenge</h1></header>

<main>
  <section class="board">
    <div id="lab"></div>
    <div class="legend">
      <span class="lg"><span class="dot" style="background:var(--start)"></span>Start</span>
      <span class="lg"><span class="dot" style="background:var(--exit)"></span>Exit</span>
      <span class="lg"><span class="dot" style="background:var(--wall)"></span>Wall</span>
      <span class="lg"><span class="dot" style="background:var(--enemy)"></span>Guard</span>
    </div>
  </section>

  <aside class="panel">
    <div class="section">
      <h2>Controls</h2>
      <div class="controls">
        <button class="btn turn" id="left">‚Ü©Ô∏è Left</button>
        <button class="btn turn" id="right">‚Ü™Ô∏è Right</button>
        <button class="btn" id="forward">‚¨ÜÔ∏è Move</button>
        <button class="btn reset" id="reset">üîÑ Reset</button>
      </div>
    </div>

    <div class="section">
      <h2>Status</h2>
      <div class="status">
        <span class="badge">Steps: <b id="steps">0</b></span>
        <span class="badge">Crashes: <b id="bumps">0</b></span>
        <span class="badge">Message: <b id="msg">Ready</b></span>
      </div>
    </div>

    <div class="section">
      <h2>Computational Thinking Pillars</h2>
      <div class="pillars">
        <div id="p_des" class="pillar">Decomposition</div>
        <div id="p_abs" class="pillar">Abstraction</div>
        <div id="p_pat" class="pillar">Pattern Recognition</div>
        <div id="p_alg" class="pillar">Algorithms</div>
      </div>
      <div id="pillarMsg" class="pillar-msg">‚Äî</div>
    </div>
  </aside>
</main>

<footer>Learning with @LaProfeVivy</footer>

<script>
const map = [
['S',0,1,0,0,0,1,0,0,0],
[1,0,1,0,1,0,1,0,1,0],
[0,0,0,0,1,0,0,0,1,0],
[0,1,1,0,1,1,1,0,1,0],
[0,0,0,0,0,0,1,0,0,0],
[1,1,1,1,1,0,1,1,1,0],
[0,0,0,0,0,0,0,0,1,0],
[0,1,1,1,1,1,1,0,1,0],
[0,0,0,0,0,0,0,0,1,'E'],
[1,1,1,1,1,1,1,0,1,1]
];
const lab=document.getElementById("lab");
const N=map.length; lab.style.setProperty('--n',N);
let start={r:0,c:0},exit={r:8,c:9};
let bot={r:start.r,c:start.c,dir:0};
let steps=0,bumps=0,moveSeries=0,turnSeries=0,lastAction=null,combinedOK=false;
let guard={r:6,c:0,dir:1,range:[0,7]};
const stepsEl=document.getElementById('steps');
const bumpsEl=document.getElementById('bumps');
const msgEl=document.getElementById('msg');
const pillarMsg=document.getElementById('pillarMsg');
const pillars={
 des:document.getElementById('p_des'),
 abs:document.getElementById('p_abs'),
 pat:document.getElementById('p_pat'),
 alg:document.getElementById('p_alg')
};
function draw(){
  lab.innerHTML='';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      if(map[r][c]===1)cell.classList.add('wall');
      if(map[r][c]==='S')cell.classList.add('start');
      if(map[r][c]==='E')cell.classList.add('exit');
      if(r===bot.r && c===bot.c){
        const holder=document.createElement('div');
        holder.className='bot';
        holder.innerHTML=`<svg viewBox="0 0 100 100" style="transform:rotate(${bot.dir*90}deg)">
          <polygon class="head" points="50,8 90,92 50,74 10,92"/>
        </svg>`;
        cell.appendChild(holder);
      }
      if(r===guard.r && c===guard.c){
        const g=document.createElement('div'); g.className='enemy'; cell.appendChild(g);
      }
      lab.appendChild(cell);
    }
  }
  stepsEl.textContent=steps;
  bumpsEl.textContent=bumps;
}
function clearPillars(){Object.values(pillars).forEach(p=>p.classList.remove('on'))}
function setPillar(key,reason){
  clearPillars(); pillars[key].classList.add('on');
  const text={
    des:"üß© Decomposition: You analyze different possible routes.",
    abs:"üéØ Abstraction: You simplify or adjust your strategy.",
    pat:"üîÅ Pattern Recognition: You detect repeated moves.",
    alg:"‚öôÔ∏è Algorithms: You follow a logical step-by-step sequence."
  };
  pillarMsg.textContent = reason || text[key];
}
function inBounds(r,c){return r>=0&&c>=0&&r<N&&c<N}
function isWall(r,c){return !inBounds(r,c)||map[r][c]===1}
function optionsAround(r,c){
  const dirs=[[-1,0],[0,1],[1,0],[0,-1]];
  let cnt=0; for(const [dr,dc] of dirs){const nr=r+dr,nc=c+dc;if(inBounds(nr,nc)&&map[nr][nc]!==1)cnt++;}
  return cnt;
}
function moveGuard(){
  let nextC = guard.c + guard.dir;
  if(nextC < guard.range[0] || nextC > guard.range[1]){ guard.dir *= -1; nextC = guard.c + guard.dir; }
  if(isWall(guard.r,nextC)){ guard.dir *= -1; nextC = guard.c + guard.dir; }
  guard.c = nextC;
}
function checkGuardHit(){
  if(bot.r===guard.r && bot.c===guard.c){
    bumps++; msgEl.textContent="üö® Caught by the guard! Rethink your plan.";
    setPillar('abs',"üéØ Abstraction: You adapt your strategy after a moving obstacle.");
    const dirs=[[1,0],[0,-1],[-1,0],[0,1]];
    const back=dirs[bot.dir]; const br=bot.r+back[0], bc=bot.c+back[1];
    if(!isWall(br,bc)){ bot.r=br; bot.c=bc; }
    return true;
  }
  return false;
}
function forward(){
  const dirs=[[-1,0],[0,1],[1,0],[0,-1]];
  const nr=bot.r+dirs[bot.dir][0], nc=bot.c+dirs[bot.dir][1];
  if(isWall(nr,nc)){
    bumps++; moveSeries=0; msgEl.textContent='‚ùå Wall ahead';
    if(optionsAround(bot.r,bot.c)>=3) setPillar('des');
    else setPillar('abs',"üéØ Abstraction: Adjusting to environmental limits.");
    moveGuard(); draw(); checkGuardHit(); return;
  }
  bot.r=nr; bot.c=nc; steps++; moveSeries++; combinedOK = combinedOK || (lastAction==='turn');
  msgEl.textContent = map[nr][nc]==='E' ? 'üèÅ Exit reached!' : '‚úîÔ∏è Moved forward';
  if(map[nr][nc]==='E'){ setPillar('alg'); moveGuard(); draw(); checkGuardHit(); return; }
  if(moveSeries>=3) setPillar('pat');
  else if(optionsAround(bot.r,bot.c)>=3) setPillar('des');
  else if(combinedOK) setPillar('alg');
  else setPillar('alg');
  lastAction='move'; turnSeries=0;
  moveGuard(); draw(); checkGuardHit();
}
function turn(side){
  bot.dir=(bot.dir + (side==='L'?3:1))%4;
  msgEl.textContent = side==='L'?'‚Ü©Ô∏è Turned left':'‚Ü™Ô∏è Turned right';
  moveSeries=0; turnSeries++; lastAction='turn';
  if(turnSeries>=2) setPillar('abs');
  else if(optionsAround(bot.r,bot.c)>=3) setPillar('des');
  else setPillar('alg',"‚öôÔ∏è Algorithms: Adjusting sequence with a correct turn.");
  moveGuard(); draw(); checkGuardHit();
}
function resetAll(){
  const openCells=[];
  for(let r=0;r<N;r++){for(let c=0;c<N;c++){if(map[r][c]!==1 && map[r][c]!=='E' && map[r][c]!=='S' && !(r===guard.r&&c===guard.c)){openCells.push({r,c});}}}
  const random=openCells[Math.floor(Math.random()*openCells.length)];
  bot={r:random.r,c:random.c,dir:Math.floor(Math.random()*4)};
  steps=0; bumps=0; moveSeries=0; turnSeries=0; lastAction=null; combinedOK=false;
  guard={r:6,c:0,dir:1,range:[0,7]};
  msgEl.textContent='Ready';
  pillarMsg.textContent='‚Äî';
  clearPillars(); draw();
}
function init(){
  draw();
  document.getElementById('left').onclick = ()=>turn('L');
  document.getElementById('right').onclick= ()=>turn('R');
  document.getElementById('forward').onclick= forward;
  document.getElementById('reset').onclick= resetAll;
  window.addEventListener('keydown',e=>{
    if(e.repeat)return;
    if(e.key==='ArrowUp')forward();
    if(e.key==='ArrowLeft')turn('L');
    if(e.key==='ArrowRight')turn('R');
    if(e.key.toLowerCase()==='r')resetAll();
  });
}
init();
</script>
</body>
</html>

